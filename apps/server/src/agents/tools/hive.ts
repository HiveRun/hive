/**
 * Hive OpenCode Custom Tools
 *
 * This file is written to .opencode/tools/hive.ts in each cell worktree.
 * OpenCode discovers and loads it at runtime, providing agents with
 * tools to monitor services and fetch logs.
 *
 * NOTE: This file is type-checked during development but embedded as a
 * string at build time. Do not import runtime dependencies from the
 * server codebase - only use Node.js built-ins and @opencode-ai/plugin.
 */

import { readFileSync } from "node:fs";
import { join } from "node:path";
import { type ToolDefinition, tool } from "@opencode-ai/plugin";

type HiveService = {
  id: string;
  name: string;
  type: string;
  status: string;
  port?: number;
  url?: string;
  pid?: number;
  command: string;
  cwd: string;
  logPath?: string;
  lastKnownError?: string | null;
  env: Record<string, string>;
  updatedAt: string;
  recentLogs?: string | null;
  totalLogLines?: number | null;
  hasMoreLogs?: boolean;
  processAlive: boolean;
  portReachable?: boolean;
};

type ServiceListResponse = {
  services: HiveService[];
};

type CellResponse = {
  setupLog?: string | null;
  setupLogPath?: string | null;
};

function buildLogQueryParams(lines?: number, offset?: number): string {
  const params = new URLSearchParams();
  if (lines != null) {
    params.set("logLines", String(lines));
  }
  if (offset != null) {
    params.set("logOffset", String(offset));
  }
  const query = params.toString();
  return query ? `?${query}` : "";
}

type HiveConfig = {
  cellId: string;
  hiveUrl: string;
};

/**
 * Reads the Hive configuration from .hive/config.json in the worktree.
 * This file is generated by Hive when the cell is created and contains
 * the cell ID and Hive server URL.
 */
function readHiveConfig(worktreePath: string): HiveConfig | Error {
  const configPath = join(worktreePath, ".hive", "config.json");

  try {
    const content = readFileSync(configPath, "utf-8");
    const config = JSON.parse(content) as Partial<HiveConfig>;

    if (!config.cellId || typeof config.cellId !== "string") {
      return new Error(
        "Invalid .hive/config.json: missing or invalid cellId. " +
          "Ensure this worktree was created by Hive."
      );
    }

    if (!config.hiveUrl || typeof config.hiveUrl !== "string") {
      return new Error(
        "Invalid .hive/config.json: missing or invalid hiveUrl. " +
          "Ensure this worktree was created by Hive."
      );
    }

    return { cellId: config.cellId, hiveUrl: config.hiveUrl };
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      return new Error(
        `Could not find .hive/config.json in ${worktreePath}. ` +
          "This tool must be run from within a Hive cell worktree."
      );
    }
    return new Error(
      `Failed to read .hive/config.json: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

/**
 * Resolves the worktree path from OpenCode context.
 * Prefers context.worktree (explicit worktree path) over context.directory.
 */
function resolveWorktreePath(context: {
  worktree?: string;
  directory?: string;
}): string | Error {
  // Prefer explicit worktree path if available
  if (context.worktree && context.worktree.length > 0) {
    return context.worktree;
  }

  // Fall back to directory only if worktree is not set
  if (context.directory && context.directory.length > 0) {
    return context.directory;
  }

  return new Error(
    "Could not determine worktree path from context. " +
      "Ensure OpenCode is running in a Hive cell worktree."
  );
}

async function fetchJson<T>(url: string, signal: AbortSignal): Promise<T> {
  const response = await fetch(url, { signal });
  if (!response.ok) {
    const body = await response.text().catch(() => "");
    const details = body ? ` ${body}` : "";
    throw new Error(
      `Request failed (${response.status}) for ${url}.${details}`
    );
  }
  return (await response.json()) as T;
}

async function fetchJsonWithInit<T>(
  url: string,
  init: RequestInit,
  signal: AbortSignal
): Promise<T> {
  const response = await fetch(url, { ...init, signal });
  if (!response.ok) {
    const body = await response.text().catch(() => "");
    const details = body ? ` ${body}` : "";
    throw new Error(
      `Request failed (${response.status}) for ${url}.${details}`
    );
  }
  return (await response.json()) as T;
}

function buildHiveToolHeaders(
  toolName: string,
  extra?: Record<string, string>
): Record<string, string> {
  return {
    "x-hive-source": "opencode",
    "x-hive-tool": toolName,
    ...(extra ?? {}),
  };
}

async function restartAllCellServices(args: {
  config: HiveConfig;
  signal: AbortSignal;
  headers: Record<string, string>;
}) {
  await fetchJsonWithInit<ServiceListResponse>(
    `${args.config.hiveUrl}/api/cells/${args.config.cellId}/services/restart`,
    { method: "POST", headers: args.headers },
    args.signal
  );
}

async function resolveServiceIdByName(args: {
  config: HiveConfig;
  signal: AbortSignal;
  serviceName: string;
}): Promise<string> {
  const list = await fetchJson<ServiceListResponse>(
    `${args.config.hiveUrl}/api/cells/${args.config.cellId}/services`,
    args.signal
  );

  const match = list.services.find(
    (service) => service.name === args.serviceName
  );
  if (!match) {
    const names = list.services.map((service) => service.name).sort();
    throw new Error(
      `Service "${args.serviceName}" not found. Available: ${names.join(", ")}`
    );
  }

  return match.id;
}

async function restartSingleService(args: {
  config: HiveConfig;
  signal: AbortSignal;
  serviceName: string;
  headers: Record<string, string>;
}): Promise<void> {
  const serviceId = await resolveServiceIdByName(args);

  await fetchJsonWithInit<HiveService>(
    `${args.config.hiveUrl}/api/cells/${args.config.cellId}/services/${serviceId}/restart`,
    { method: "POST", headers: args.headers },
    args.signal
  );
}

function removeServiceLogs(service: HiveService): HiveService {
  return { ...service, recentLogs: undefined };
}

function formatRestartTitle(serviceName?: string): string {
  return serviceName
    ? `Restarted service: ${serviceName}`
    : "Restarted all services.";
}

function formatServicesText(
  serviceList: HiveService[],
  includeLogs: boolean
): string {
  if (serviceList.length === 0) {
    return "No services found for this cell.";
  }

  return serviceList
    .map((service) => formatSingleServiceText(service, includeLogs))
    .join("\n\n");
}

function formatPortReachable(value: boolean | undefined): string | null {
  if (value == null) {
    return null;
  }
  return value ? "yes" : "no";
}

function formatNumber(value: number | undefined): string | null {
  if (value == null) {
    return null;
  }
  return String(value);
}

function formatLogHeader(service: HiveService): string {
  if (service.totalLogLines == null) {
    return "Recent logs:";
  }
  const moreText = service.hasMoreLogs ? ", more available" : "";
  return `Recent logs (${service.totalLogLines} total lines${moreText}):`;
}

function formatServiceLogHeader(service: HiveService): string {
  if (service.totalLogLines == null) {
    return "Recent logs:";
  }
  const moreText = service.hasMoreLogs ? ", more available with logOffset" : "";
  return `Recent logs (${service.totalLogLines} total lines${moreText}):`;
}

function formatServiceLogsText(service: HiveService): string {
  return [
    `Service: ${service.name}`,
    `Status: ${service.status}`,
    `Log path: ${service.logPath ?? "(unknown)"}`,
    formatServiceLogHeader(service),
    service.recentLogs ?? "(no log output yet)",
  ].join("\n");
}

function formatSingleServiceText(
  service: HiveService,
  includeLogs: boolean
): string {
  const lines: [string, string | null][] = [
    ["Service", service.name],
    ["Status", service.status],
    ["Type", service.type || null],
    ["Port", formatNumber(service.port)],
    ["URL", service.url ?? null],
    ["PID", formatNumber(service.pid)],
    ["Process", service.processAlive ? "running" : "not running"],
    ["Port reachable", formatPortReachable(service.portReachable)],
    ["Last error", service.lastKnownError ?? null],
  ];

  const output = lines.flatMap(([label, value]) =>
    value ? [`${label}: ${value}`] : []
  );

  if (includeLogs) {
    const logHeader = formatLogHeader(service);
    output.push(`${logHeader}\n${service.recentLogs ?? "(no log output yet)"}`);
  }

  return output.join("\n");
}

export const services: ToolDefinition = tool({
  description: `Check the status of all services (backend, frontend, database, etc.) running in this cell.

USE THIS TOOL WHEN:
- You need to debug why something isn't working (check if services are running)
- You want to see error messages or stack traces from service logs
- You need to find which port a service is running on
- You want to check if a service crashed or restarted

RETURNS: For each service: name, status (running/stopped/error), port, URL, process info, and recent log output.

PAGINATION: By default returns last 200 log lines per service. Use logLines/logOffset to get more or paginate through history.`,
  args: {
    includeLogs: tool.schema
      .boolean()
      .optional()
      .describe(
        "Include recent log output for each service. Set to false for a quick status check without logs. Default: true."
      ),
    logLines: tool.schema
      .number()
      .optional()
      .describe(
        "Number of log lines to return per service (1-2000). Use higher values to see more history. Default: 200."
      ),
    logOffset: tool.schema
      .number()
      .optional()
      .describe(
        "Skip this many lines from the end. Use with logLines to paginate: offset=0 gets newest, offset=200 gets the 200 lines before that."
      ),
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
  },
  async execute(args, context) {
    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const includeLogs = args.includeLogs ?? true;
    const format = args.format ?? "text";
    const queryParams = buildLogQueryParams(args.logLines, args.logOffset);

    try {
      const payload = await fetchJson<ServiceListResponse>(
        `${config.hiveUrl}/api/cells/${config.cellId}/services${queryParams}`,
        context.abort
      );

      if (format === "json") {
        const servicesPayload = includeLogs
          ? payload.services
          : payload.services.map((service) => ({
              ...service,
              recentLogs: undefined,
            }));
        return JSON.stringify({ services: servicesPayload }, null, 2);
      }

      return formatServicesText(payload.services, includeLogs);
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});

export const service_logs: ToolDefinition = tool({
  description: `Get log output for a specific service by name.

USE THIS TOOL WHEN:
- You already know which service has the problem and want to focus on its logs
- You need more log history than hive_services provides
- You want to paginate through a service's log history to find when an error started

EXAMPLE: If hive_services shows "web" service has status "error", use this to get more detailed logs.

TIP: If you don't know the service name, call hive_services first to see available services.`,
  args: {
    serviceName: tool.schema
      .string()
      .describe(
        "The service name to get logs for. Must match exactly (e.g., 'web', 'api', 'db'). Call hive_services first if unsure of available names."
      ),
    logLines: tool.schema
      .number()
      .optional()
      .describe(
        "Number of log lines to return (1-2000). Use higher values like 500-1000 to see more context around errors. Default: 200."
      ),
    logOffset: tool.schema
      .number()
      .optional()
      .describe(
        "Skip this many lines from the end to see older logs. Example: logOffset=200, logLines=200 returns lines 201-400 from the end."
      ),
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
  },
  async execute(args, context) {
    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const format = args.format ?? "text";
    const queryParams = buildLogQueryParams(args.logLines, args.logOffset);
    const headers = buildHiveToolHeaders("hive_service_logs", {
      "x-hive-audit-event": "service.logs.read",
      "x-hive-service-name": args.serviceName,
    });

    try {
      const payload = await fetchJsonWithInit<ServiceListResponse>(
        `${config.hiveUrl}/api/cells/${config.cellId}/services${queryParams}`,
        { method: "GET", headers },
        context.abort
      );

      const match = payload.services.find(
        (service) => service.name === args.serviceName
      );

      if (!match) {
        const names = payload.services.map((service) => service.name).sort();
        return `Error: Service "${args.serviceName}" not found. Available: ${names.join(", ")}`;
      }

      if (format === "json") {
        return JSON.stringify(
          {
            name: match.name,
            status: match.status,
            recentLogs: match.recentLogs ?? "",
            logPath: match.logPath ?? null,
            totalLogLines: match.totalLogLines ?? null,
            hasMoreLogs: match.hasMoreLogs ?? false,
          },
          null,
          2
        );
      }

      return formatServiceLogsText(match);
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});

export const setup_logs: ToolDefinition = tool({
  description: `Get logs from the cell's initial setup/provisioning phase.

USE THIS TOOL WHEN:
- The cell failed during initial setup (before services started)
- You need to debug dependency installation issues (npm install, pip install, etc.)
- You want to see what commands ran during cell initialization
- Services won't start and you suspect a setup problem

WHAT THIS SHOWS: Output from setup commands defined in the template (e.g., package installation, database migrations, build steps) that ran when the cell was first created.

NOTE: This is different from service logs - setup runs once when the cell is created, services run continuously after.`,
  args: {
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
  },
  async execute(args, context) {
    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const format = args.format ?? "text";
    const headers = buildHiveToolHeaders("hive_setup_logs", {
      "x-hive-audit-event": "setup.logs.read",
    });

    try {
      const payload = await fetchJsonWithInit<CellResponse>(
        `${config.hiveUrl}/api/cells/${config.cellId}`,
        { method: "GET", headers },
        context.abort
      );

      if (format === "json") {
        return JSON.stringify(
          {
            setupLog: payload.setupLog ?? "",
            setupLogPath: payload.setupLogPath ?? null,
          },
          null,
          2
        );
      }

      return [
        `Setup log path: ${payload.setupLogPath ?? "(unknown)"}`,
        "Setup logs:",
        payload.setupLog ?? "(no setup log output yet)",
      ].join("\n");
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});

export const restart_services: ToolDefinition = tool({
  description: `Restart ALL services for this cell.

THIS IS A DESTRUCTIVE OPERATION:
- Stops services and starts them again
- Interrupts any in-flight requests

USE THIS TOOL WHEN:
- You need a full clean restart of the cell (e.g., after broad config changes)

IF YOU ONLY NEED ONE SERVICE: use hive_restart_service instead.

SAFETY: You must pass confirm=true or the tool will refuse to run.

TIP: Call hive_services after restarting to confirm everything is healthy.`,
  args: {
    includeLogs: tool.schema
      .boolean()
      .optional()
      .describe(
        "Include recent log output in the final status display. Default: false."
      ),
    logLines: tool.schema
      .number()
      .optional()
      .describe(
        "Number of log lines to show in the final status display (1-2000). Default: 200."
      ),
    logOffset: tool.schema
      .number()
      .optional()
      .describe(
        "Skip this many lines from the end in the final status display (pagination)."
      ),
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
    confirm: tool.schema
      .boolean()
      .optional()
      .describe(
        "Required. Set true to actually restart services. This prevents accidental restarts."
      ),
  },
  async execute(args, context) {
    if (args.confirm !== true) {
      return "Refusing to restart services without confirm=true.";
    }

    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const includeLogs = args.includeLogs ?? false;
    const format = args.format ?? "text";
    const queryParams = buildLogQueryParams(args.logLines, args.logOffset);
    const headers = buildHiveToolHeaders("hive_restart_services");

    try {
      await restartAllCellServices({ config, signal: context.abort, headers });

      const final = await fetchJson<ServiceListResponse>(
        `${config.hiveUrl}/api/cells/${config.cellId}/services${queryParams}`,
        context.abort
      );

      if (format === "json") {
        const servicesPayload = includeLogs
          ? final.services
          : final.services.map((service) => removeServiceLogs(service));
        return JSON.stringify(
          {
            restarted: "all",
            services: servicesPayload,
          },
          null,
          2
        );
      }

      const title = formatRestartTitle();
      return [title, "", formatServicesText(final.services, includeLogs)].join(
        "\n"
      );
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});

export const restart_service: ToolDefinition = tool({
  description: `Restart a SINGLE service for this cell.

THIS IS A DESTRUCTIVE OPERATION:
- Stops the service and starts it again
- Interrupts any in-flight requests to that service

USE THIS TOOL WHEN:
- One service is wedged/crashed and you want minimal blast radius

SAFETY: You must pass confirm=true or the tool will refuse to run.

TIP: Call hive_services after restarting to confirm everything is healthy.`,
  args: {
    serviceName: tool.schema
      .string()
      .describe(
        "The service name to restart (exact match). Call hive_services first if unsure of available names."
      ),
    includeLogs: tool.schema
      .boolean()
      .optional()
      .describe(
        "Include recent log output in the final status display. Default: false."
      ),
    logLines: tool.schema
      .number()
      .optional()
      .describe(
        "Number of log lines to show in the final status display (1-2000). Default: 200."
      ),
    logOffset: tool.schema
      .number()
      .optional()
      .describe(
        "Skip this many lines from the end in the final status display (pagination)."
      ),
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
    confirm: tool.schema
      .boolean()
      .optional()
      .describe(
        "Required. Set true to actually restart the service. This prevents accidental restarts."
      ),
  },
  async execute(args, context) {
    if (args.confirm !== true) {
      return "Refusing to restart a service without confirm=true.";
    }

    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const includeLogs = args.includeLogs ?? false;
    const format = args.format ?? "text";
    const queryParams = buildLogQueryParams(args.logLines, args.logOffset);
    const headers = buildHiveToolHeaders("hive_restart_service");

    try {
      await restartSingleService({
        config,
        signal: context.abort,
        serviceName: args.serviceName,
        headers,
      });

      const final = await fetchJson<ServiceListResponse>(
        `${config.hiveUrl}/api/cells/${config.cellId}/services${queryParams}`,
        context.abort
      );

      if (format === "json") {
        const servicesPayload = includeLogs
          ? final.services
          : final.services.map((service) => removeServiceLogs(service));
        return JSON.stringify(
          {
            restarted: args.serviceName,
            services: servicesPayload,
          },
          null,
          2
        );
      }

      const title = formatRestartTitle(args.serviceName);
      return [title, "", formatServicesText(final.services, includeLogs)].join(
        "\n"
      );
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});

export const rerun_setup: ToolDefinition = tool({
  description: `Re-run cell setup/provisioning.

This re-executes the template setup commands (dependency installs, migrations, etc.) and re-ensures services.

USE THIS TOOL WHEN:
- The cell failed provisioning and needs a retry after fixing the workspace
- Dependencies or migrations are out of date and you want to re-run setup

SAFETY: You must pass confirm=true or the tool will refuse to run.`,
  args: {
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
    confirm: tool.schema
      .boolean()
      .optional()
      .describe(
        "Required. Set true to actually rerun setup. This prevents accidental provisioning retries."
      ),
  },
  async execute(args, context) {
    if (args.confirm !== true) {
      return "Refusing to rerun setup without confirm=true.";
    }

    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const format = args.format ?? "text";
    const headers = buildHiveToolHeaders("hive_rerun_setup");

    try {
      const payload = await fetchJsonWithInit<Record<string, unknown>>(
        `${config.hiveUrl}/api/cells/${config.cellId}/setup/retry`,
        { method: "POST", headers },
        context.abort
      );

      if (format === "json") {
        return JSON.stringify(payload, null, 2);
      }

      const status =
        typeof payload.status === "string" ? payload.status : "(unknown)";
      const setupLogPath =
        typeof payload.setupLogPath === "string"
          ? payload.setupLogPath
          : "(unknown)";
      const setupLog =
        typeof payload.setupLog === "string" ? payload.setupLog : null;

      return [
        `Setup rerun requested. Current cell status: ${status}`,
        `Setup log path: ${setupLogPath}`,
        "Setup logs:",
        setupLog ?? "(no setup log output yet)",
      ].join("\n");
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});
