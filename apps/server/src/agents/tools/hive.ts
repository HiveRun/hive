/**
 * Hive OpenCode Custom Tools
 *
 * This file is written to .opencode/tools/hive.ts in each cell worktree.
 * OpenCode discovers and loads it at runtime, providing agents with
 * tools to monitor services and fetch logs.
 *
 * NOTE: This file is type-checked during development but embedded as a
 * string at build time. Do not import runtime dependencies from the
 * server codebase - only use Node.js built-ins and @opencode-ai/plugin.
 */

import { readFileSync } from "node:fs";
import { join } from "node:path";
import { tool } from "@opencode-ai/plugin";

type HiveService = {
  id: string;
  name: string;
  type: string;
  status: string;
  port?: number;
  url?: string;
  pid?: number;
  command: string;
  cwd: string;
  logPath?: string;
  lastKnownError?: string | null;
  env: Record<string, string>;
  updatedAt: string;
  recentLogs?: string | null;
  totalLogLines?: number | null;
  hasMoreLogs?: boolean;
  processAlive: boolean;
  portReachable?: boolean;
};

type ServiceListResponse = {
  services: HiveService[];
};

type CellResponse = {
  setupLog?: string | null;
  setupLogPath?: string | null;
};

function buildLogQueryParams(lines?: number, offset?: number): string {
  const params = new URLSearchParams();
  if (lines != null) {
    params.set("logLines", String(lines));
  }
  if (offset != null) {
    params.set("logOffset", String(offset));
  }
  const query = params.toString();
  return query ? `?${query}` : "";
}

type HiveConfig = {
  cellId: string;
  hiveUrl: string;
};

/**
 * Reads the Hive configuration from .hive/config.json in the worktree.
 * This file is generated by Hive when the cell is created and contains
 * the cell ID and Hive server URL.
 */
function readHiveConfig(worktreePath: string): HiveConfig | Error {
  const configPath = join(worktreePath, ".hive", "config.json");

  try {
    const content = readFileSync(configPath, "utf-8");
    const config = JSON.parse(content) as Partial<HiveConfig>;

    if (!config.cellId || typeof config.cellId !== "string") {
      return new Error(
        "Invalid .hive/config.json: missing or invalid cellId. " +
          "Ensure this worktree was created by Hive."
      );
    }

    if (!config.hiveUrl || typeof config.hiveUrl !== "string") {
      return new Error(
        "Invalid .hive/config.json: missing or invalid hiveUrl. " +
          "Ensure this worktree was created by Hive."
      );
    }

    return { cellId: config.cellId, hiveUrl: config.hiveUrl };
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      return new Error(
        `Could not find .hive/config.json in ${worktreePath}. ` +
          "This tool must be run from within a Hive cell worktree."
      );
    }
    return new Error(
      `Failed to read .hive/config.json: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

/**
 * Resolves the worktree path from OpenCode context.
 * Prefers context.worktree (explicit worktree path) over context.directory.
 */
function resolveWorktreePath(context: {
  worktree?: string;
  directory?: string;
}): string | Error {
  // Prefer explicit worktree path if available
  if (context.worktree && context.worktree.length > 0) {
    return context.worktree;
  }

  // Fall back to directory only if worktree is not set
  if (context.directory && context.directory.length > 0) {
    return context.directory;
  }

  return new Error(
    "Could not determine worktree path from context. " +
      "Ensure OpenCode is running in a Hive cell worktree."
  );
}

async function fetchJson<T>(url: string, signal: AbortSignal): Promise<T> {
  const response = await fetch(url, { signal });
  if (!response.ok) {
    const body = await response.text().catch(() => "");
    const details = body ? ` ${body}` : "";
    throw new Error(
      `Request failed (${response.status}) for ${url}.${details}`
    );
  }
  return (await response.json()) as T;
}

function formatServicesText(
  serviceList: HiveService[],
  includeLogs: boolean
): string {
  if (serviceList.length === 0) {
    return "No services found for this cell.";
  }

  return serviceList
    .map((service) => formatSingleServiceText(service, includeLogs))
    .join("\n\n");
}

function formatPortReachable(value: boolean | undefined): string | null {
  if (value == null) {
    return null;
  }
  return value ? "yes" : "no";
}

function formatNumber(value: number | undefined): string | null {
  if (value == null) {
    return null;
  }
  return String(value);
}

function formatLogHeader(service: HiveService): string {
  if (service.totalLogLines == null) {
    return "Recent logs:";
  }
  const moreText = service.hasMoreLogs ? ", more available" : "";
  return `Recent logs (${service.totalLogLines} total lines${moreText}):`;
}

function formatServiceLogHeader(service: HiveService): string {
  if (service.totalLogLines == null) {
    return "Recent logs:";
  }
  const moreText = service.hasMoreLogs ? ", more available with logOffset" : "";
  return `Recent logs (${service.totalLogLines} total lines${moreText}):`;
}

function formatServiceLogsText(service: HiveService): string {
  return [
    `Service: ${service.name}`,
    `Status: ${service.status}`,
    `Log path: ${service.logPath ?? "(unknown)"}`,
    formatServiceLogHeader(service),
    service.recentLogs ?? "(no log output yet)",
  ].join("\n");
}

function formatSingleServiceText(
  service: HiveService,
  includeLogs: boolean
): string {
  const lines: [string, string | null][] = [
    ["Service", service.name],
    ["Status", service.status],
    ["Type", service.type || null],
    ["Port", formatNumber(service.port)],
    ["URL", service.url ?? null],
    ["PID", formatNumber(service.pid)],
    ["Process", service.processAlive ? "running" : "not running"],
    ["Port reachable", formatPortReachable(service.portReachable)],
    ["Last error", service.lastKnownError ?? null],
  ];

  const output = lines.flatMap(([label, value]) =>
    value ? [`${label}: ${value}`] : []
  );

  if (includeLogs) {
    const logHeader = formatLogHeader(service);
    output.push(`${logHeader}\n${service.recentLogs ?? "(no log output yet)"}`);
  }

  return output.join("\n");
}

export const services = tool({
  description: `Check the status of all services (backend, frontend, database, etc.) running in this cell.

USE THIS TOOL WHEN:
- You need to debug why something isn't working (check if services are running)
- You want to see error messages or stack traces from service logs
- You need to find which port a service is running on
- You want to check if a service crashed or restarted

RETURNS: For each service: name, status (running/stopped/error), port, URL, process info, and recent log output.

PAGINATION: By default returns last 200 log lines per service. Use logLines/logOffset to get more or paginate through history.`,
  args: {
    includeLogs: tool.schema
      .boolean()
      .optional()
      .describe(
        "Include recent log output for each service. Set to false for a quick status check without logs. Default: true."
      ),
    logLines: tool.schema
      .number()
      .optional()
      .describe(
        "Number of log lines to return per service (1-2000). Use higher values to see more history. Default: 200."
      ),
    logOffset: tool.schema
      .number()
      .optional()
      .describe(
        "Skip this many lines from the end. Use with logLines to paginate: offset=0 gets newest, offset=200 gets the 200 lines before that."
      ),
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
  },
  async execute(args, context) {
    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const includeLogs = args.includeLogs ?? true;
    const format = args.format ?? "text";
    const queryParams = buildLogQueryParams(args.logLines, args.logOffset);

    try {
      const payload = await fetchJson<ServiceListResponse>(
        `${config.hiveUrl}/api/cells/${config.cellId}/services${queryParams}`,
        context.abort
      );

      if (format === "json") {
        const servicesPayload = includeLogs
          ? payload.services
          : payload.services.map((service) => ({
              ...service,
              recentLogs: undefined,
            }));
        return JSON.stringify({ services: servicesPayload }, null, 2);
      }

      return formatServicesText(payload.services, includeLogs);
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});

export const service_logs = tool({
  description: `Get log output for a specific service by name.

USE THIS TOOL WHEN:
- You already know which service has the problem and want to focus on its logs
- You need more log history than hive_services provides
- You want to paginate through a service's log history to find when an error started

EXAMPLE: If hive_services shows "web" service has status "error", use this to get more detailed logs.

TIP: If you don't know the service name, call hive_services first to see available services.`,
  args: {
    serviceName: tool.schema
      .string()
      .describe(
        "The service name to get logs for. Must match exactly (e.g., 'web', 'api', 'db'). Call hive_services first if unsure of available names."
      ),
    logLines: tool.schema
      .number()
      .optional()
      .describe(
        "Number of log lines to return (1-2000). Use higher values like 500-1000 to see more context around errors. Default: 200."
      ),
    logOffset: tool.schema
      .number()
      .optional()
      .describe(
        "Skip this many lines from the end to see older logs. Example: logOffset=200, logLines=200 returns lines 201-400 from the end."
      ),
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
  },
  async execute(args, context) {
    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const format = args.format ?? "text";
    const queryParams = buildLogQueryParams(args.logLines, args.logOffset);

    try {
      const payload = await fetchJson<ServiceListResponse>(
        `${config.hiveUrl}/api/cells/${config.cellId}/services${queryParams}`,
        context.abort
      );

      const match = payload.services.find(
        (service) => service.name === args.serviceName
      );

      if (!match) {
        const names = payload.services.map((service) => service.name).sort();
        return `Error: Service "${args.serviceName}" not found. Available: ${names.join(", ")}`;
      }

      if (format === "json") {
        return JSON.stringify(
          {
            name: match.name,
            status: match.status,
            recentLogs: match.recentLogs ?? "",
            logPath: match.logPath ?? null,
            totalLogLines: match.totalLogLines ?? null,
            hasMoreLogs: match.hasMoreLogs ?? false,
          },
          null,
          2
        );
      }

      return formatServiceLogsText(match);
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});

export const setup_logs = tool({
  description: `Get logs from the cell's initial setup/provisioning phase.

USE THIS TOOL WHEN:
- The cell failed during initial setup (before services started)
- You need to debug dependency installation issues (npm install, pip install, etc.)
- You want to see what commands ran during cell initialization
- Services won't start and you suspect a setup problem

WHAT THIS SHOWS: Output from setup commands defined in the template (e.g., package installation, database migrations, build steps) that ran when the cell was first created.

NOTE: This is different from service logs - setup runs once when the cell is created, services run continuously after.`,
  args: {
    format: tool.schema
      .enum(["text", "json"])
      .optional()
      .describe(
        "Output format. Use 'json' for programmatic parsing. Default: text."
      ),
  },
  async execute(args, context) {
    const worktreePath = resolveWorktreePath(context);
    if (worktreePath instanceof Error) {
      return `Error: ${worktreePath.message}`;
    }

    const config = readHiveConfig(worktreePath);
    if (config instanceof Error) {
      return `Error: ${config.message}`;
    }

    const format = args.format ?? "text";

    try {
      const payload = await fetchJson<CellResponse>(
        `${config.hiveUrl}/api/cells/${config.cellId}`,
        context.abort
      );

      if (format === "json") {
        return JSON.stringify(
          {
            setupLog: payload.setupLog ?? "",
            setupLogPath: payload.setupLogPath ?? null,
          },
          null,
          2
        );
      }

      return [
        `Setup log path: ${payload.setupLogPath ?? "(unknown)"}`,
        "Setup logs:",
        payload.setupLog ?? "(no setup log output yet)",
      ].join("\n");
    } catch (error) {
      return `Error: ${error instanceof Error ? error.message : String(error)}`;
    }
  },
});
